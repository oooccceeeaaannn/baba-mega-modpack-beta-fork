---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by 16021.
--- DateTime: 2024/7/24 19:27
---
function findclassunits()
    local result = {}
    local alreadydone = {}
    local checkrecursion = {}
    local related = {}

    local identifier = ""
    local fullid = {}

    if (featureindex["class"] ~= nil) then
        for i,v in ipairs(featureindex["class"]) do
            local rule = v[1]
            local conds = v[2]
            local ids = v[3]

            local name = rule[1]
            local subid = ""

            if (rule[2] == "is") and (is_str_broad_noun(name) or is_str_special_prefixed(name)) and (name ~= "text") and (get_broaded_str(name) ~= "text") then
                if (objectlist[name] ~= nil) and (alreadydone[name] == nil) then
                    local these = findall({name,{}})
                    alreadydone[name] = 1

                    if (#these > 0) then
                        for a,b in ipairs(these) do
                            local bunit = mmf.newObject(b)
                            local valid = true

                            if (featureindex["broken"] ~= nil) then
                                if (hasfeature(getname(bunit),"is","broken",b,bunit.values[XPOS],bunit.values[YPOS]) ~= nil) then
                                    valid = false
                                end
                            end

                            if valid then
                                table.insert(result, {b, conds})
                                subid = subid .. name
                                -- LISÄÄ TÄHÄN LISÄÄ DATAA
                            end
                        end
                    end
                end

                if (#subid > 0) then
                    for a,b in ipairs(conds) do
                        local condtype = b[1]
                        local params = b[2] or {}

                        subid = subid .. condtype

                        if (#params > 0) then
                            for c,d in ipairs(params) do
                                subid = subid .. tostring(d)

                                related = findunits(d,related,conds)
                            end
                        end
                    end
                end

                table.insert(fullid, subid)

                --MF_alert("Going through " .. name)

                if (#ids > 0) then
                    if (#ids[1] == 1) then
                        local firstunit = mmf.newObject(ids[1][1])

                        local notname = name
                        if (string.sub(name, 1, 4) == "not ") then
                            notname = string.sub(name, 5)
                        end

                        if (firstunit.strings[UNITNAME] ~= "text_" .. name) and (firstunit.strings[UNITNAME] ~= "text_" .. notname) then
                            --MF_alert("Checking recursion for " .. name)
                            table.insert(checkrecursion, {name, i})
                        end
                    end
                else
                    MF_alert("No ids listed in Word-related rule! rules.lua line 1302 - this needs fixing asap (related to grouprules line 1118)")
                end
            end
        end

        table.sort(fullid)
        for i,v in ipairs(fullid) do
            -- MF_alert("Adding " .. v .. " to id")
            identifier = identifier .. v
        end

        --MF_alert("Identifier: " .. identifier)

    end

    for a,checkname_ in ipairs(checkrecursion) do
        local found = false

        local checkname = checkname_[1]

        local b = checkname
        if (string.sub(b, 1, 4) == "not ") then
            b = string.sub(checkname, 5)
        end

        for i,v in ipairs(featureindex["class"]) do
            local rule = v[1]
            local ids = v[3]
            local tags = v[4]

            -- Gotta change this to prevent some false infinite loops
            if can_refer(rule[1], b) then
                for c,g in ipairs(ids) do
                    for a,d in ipairs(g) do
                        local idunit = mmf.newObject(d)

                        -- Tässä pitäisi testata myös Group!
                        if (idunit.strings[UNITNAME] == "text_" .. rule[1]) or ((idunit.strings[UNITNAME] == "glyph_" .. rule[1]) and (tags[1] == "glyphrule")) or ((idunit.strings[UNITNAME] == rule[1]) and (tags[1] == "glyphrule")) or ((rule[1] == "all") and (rule[1] ~= "glyph")) then
                            --MF_alert("Matching objects - found")
                            found = true
                        elseif (string.sub(rule[1], 1, 5) == "group") then
                            --MF_alert("Group - found")
                            found = true
                        elseif (rule[1] ~= checkname) and (((string.sub(rule[1], 1, 3) == "not") and (rule[1] ~= "glyph")) or ((rule[1] == "not all") and (rule[1] == "glyph"))) then
                            --MF_alert("Not Object - found")
                            found = true
                        elseif idunit.strings[UNITNAME] == "text_this" then
                            -- Note: this could match any "this is word" or "not this is word" rules. But we handle the raycast buisness in testcond
                            found = true
                        elseif (idunit.strings[UNITNAME] == "text_text_") then
                            found = true
                        end
                    end
                end

                for c,g in ipairs(tags) do
                    if (g == "mimic") then
                        found = true
                    end
                end
            end
        end

        if (found == false) then
            --MF_alert("Wordunit status for " .. b .. " is unstable!")
            identifier = "null"
            classunits = {}

            for i,v in pairs(featureindex["class"]) do
                local rule = v[1]
                local ids = v[3]

                --MF_alert("Checking to disable: " .. rule[1] .. " " .. ", not " .. b)

                if (rule[1] == b) or (rule[1] == "not " .. b) then
                    v[2] = {{"never",{}}}
                end
            end

            if (string.sub(checkname, 1, 4) == "not ") then
                local notrules_word = notfeatures["class"]
                local notrules_id = checkname_[2]
                local disablethese = notrules_word[notrules_id]

                for i,v in ipairs(disablethese) do
                    v[2] = {{"never",{}}}
                end
            end
        end
    end
    --MF_alert("Current id (end): " .. identifier)

    return result,identifier,related
end

function checkclasschanges(unitid)
    if (#classunits > 0) then
        for i,v in ipairs(classunits) do
            if (v[1] == unitid) then
                updatecode = 1
                return
            end
        end
    end

    if (#classrelatedunits > 0) then
        for i,v in ipairs(classrelatedunits) do
            if (v[1] == unitid) then
                updatecode = 1
                return
            end
        end
    end
end
